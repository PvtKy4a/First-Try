#include <EncButton.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

EncButton<EB_TICK, 2, 3, 4> enc(INPUT);
EncButton<EB_TICK, 12> btn(INPUT_PULLUP);
LiquidCrystal_I2C lcd(0x3f, 20, 4);

#define sp7 6
#define sp5 7
#define sp3 8
#define sp1 9
#define pre_in 10
#define led 11

const char si[] PROGMEM = "Sim:    ";      //строки хранятся в постоянной памяти, чтобы не загружать оперативную
const char st[] PROGMEM = "State:  ";
const char pe[] PROGMEM = "Period: ";
const char le[] PROGMEM = "Uptime: ";
const char* const names[] PROGMEM = {si, st, pe, le,};    //массив ссылок на эти строки

void print_names(int names_num);      //функция, которая будет выводить строки
void uptime(int uptime_sec);

void setup() {

  lcd.init();
  lcd.backlight();

  pinMode(sp7, OUTPUT);
  pinMode(sp5, OUTPUT);
  pinMode(sp3, OUTPUT);
  pinMode(sp1, OUTPUT);
  pinMode(pre_in, OUTPUT);
  pinMode(led, OUTPUT);

}

void loop() {

  enc.tick();   //опрос энкодера
  btn.tick();   //опрос кнопки

  static uint32_t period = 30;
  if (enc.isLeft()) {
    if (enc.isFast()) period = constrain(period - 5, 15, 60);   //если энкодер быстро влево, то уменьшить период на 5 в пределах от 15 до 60
    else period = constrain(period - 1, 15, 60);                //если энкодер влево, то уменьшить период на 1 в пределах от 15 до 60
  }
  if (enc.isRight()) {
    if (enc.isFast()) period = constrain(period + 5, 15, 60);   //если энкодер быстро вправо, то увеличть период на 5 в пределах от 15 до 60
    else period = constrain(period + 1, 15, 60);                //если энкодер вправо, то увеличть период на 1 в пределах от 15 до 60
  }

  static uint8_t sp_num [] {sp7, sp5, sp3, sp1, pre_in};              //массив номеров точек
  static uint8_t sp_num_size = sizeof(sp_num) / sizeof(sp_num[0]);    //его размер
  static bool stop_flag = true;   //"стоп" флаг, включает и выключает симуляцию поезда
  static bool start_flag;         //"старт" флаг, устанавливает начальное состояние симуляции
  static uint8_t upd_countr = 0;
  if (btn.isClick()) {            //если кнопка нажата
    stop_flag = !stop_flag;       //изменить состояние "стоп" флага
    if (stop_flag) {              //если он поднят
      ++upd_countr;
      for (uint8_t i = 0; i < sp_num_size; ++i) digitalWrite(sp_num[i], LOW);    //освободить все точки
    } else start_flag = true;       //иначе поднять "старт" флаг
  }
  if (!stop_flag) {               //если "стоп" флаг опущен, включить симуляцию поезда
    static bool state_flag;       //флаг состояний
    static uint8_t countr;        //счетчик
    static uint32_t period_tmr;   //таймер
    if (start_flag) {             //если "старт" флаг поднят
      digitalWrite(sp_num[0], HIGH);    //первая точка "занята", начальное состояние
      countr = 1;                 //установить счетчик в начальное состояние
      upd_countr = 1;
      state_flag = true;          //установить флаг состояний в начальное состояние
      period_tmr = millis();      //обновить таймер
      start_flag = false;         //"старт" флаг опустить
    }
    if (millis() - period_tmr >= period * 1000) {     //дальше почти без изменений
      period_tmr = millis();
      ++upd_countr;
      switch (state_flag) {
        case (true): {
            digitalWrite(sp_num[countr], HIGH);
            if (countr == 1 && digitalRead(sp_num[sp_num_size - 1])) digitalWrite(sp_num[sp_num_size - 1], LOW);      //если счетчик в начальном состоянии, а последняя точка нет, выключить ее
            state_flag = false;
          }
          break;
        case (false): {
            digitalWrite(sp_num[countr - 1], LOW);
            ++countr;
            if (countr == sp_num_size) start_flag = true;       //если счетчик дошел до конца массива, вернуть начальное состояние
            state_flag = true;
          }
          break;
      }
    }
  }

  static uint32_t upd_tmr;
  if (millis() - upd_tmr >= 50) {    //вывод информации на дисплей построчно
    upd_tmr = millis();
    static bool print_names_flag = true;
    static uint8_t column = 1;
    lcd.setCursor(column, 0);
    if (print_names_flag) print_names(&names[0]);       //"Sim"
    lcd.print((stop_flag) ? F("off") : F("on "));       //off, если "стоп" флаг поднят и on, если опущен
    lcd.setCursor(column, 1);
    if (print_names_flag) print_names(&names[1]);       //"State"
    static uint8_t pre_upd_countr = 1;
    if (pre_upd_countr != upd_countr) {                 //состояние точек обновляется по факту изменения
      for (uint8_t i = 0, j = 6; i < sp_num_size; ++i, ++j) {
        bool sp_state = (digitalRead(j));               //считать состояние точки
        lcd.print(sp_state);                            //вывести на дисплей
        lcd.print(" ");
      }
      pre_upd_countr = upd_countr;
    }
    lcd.setCursor(column, 2);
    if (print_names_flag) print_names(&names[2]);       //"Period"
    lcd.print(period);                                  //значение периода
    if (print_names_flag) lcd.print(F(" sec"));         //"sec"
    lcd.setCursor(column, 3);
    if (print_names_flag) print_names(&names[3]);       //"Uptime"
    static uint32_t uptime_tmr;
    static int sec = 0;
    if (!stop_flag && millis() - uptime_tmr >= 1000) {
      uptime_tmr = millis();
      sec += 1;
    } else if (stop_flag) sec = 0;
    uptime(sec);
    if (print_names_flag) {
      print_names_flag = false;
      column = 9;
    }
  }

}

void uptime(int uptime_sec) {
  int sec = uptime_sec;
  byte miin = sec / 60;
  byte this_min = miin % 60;
  byte this_hour = sec / 3600;
  if (this_hour < 10) lcd.print(0);
  lcd.print(this_hour);
  lcd.print(":");
  if (this_min < 10) lcd.print(0);
  lcd.print(this_min);
  lcd.print(":");
  byte this_sec = sec % 60;
  if (this_sec < 10) lcd.print(0);
  lcd.print(this_sec);
}

void print_names(int names_num) {             //функция посимвольно собирает переданную строку из постоянной памяти
  char buff[20];                              //в буфер
  uint16_t ptr = pgm_read_word(names_num);
  uint8_t i = 0;
  do {
    buff[i] = (char)(pgm_read_byte(ptr++));
  } while (buff[i++] != NULL);                //пока не дойдет до символа NULL
  lcd.print(buff);                            //и выводит на дисплей
}
