#include <EncButton.h>
EncButton<EB_TICK, 2, 3, 4> enc(INPUT);
EncButton<EB_TICK, 12> btn(INPUT_PULLUP);

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
LiquidCrystal_I2C lcd(0x3f, 20, 4);

#define sp7 6
#define sp5 7
#define sp3 8
#define sp1 9
#define pre_in 10
#define led 11

const char st[] PROGMEM = "State:  ";         //строки хранятся в постоянной памяти, чтобы не загружать оперативную
const char pe[] PROGMEM = "Period: ";
const char le[] PROGMEM = "Uptime: ";
const char ti[] PROGMEM = "Timer:  ";
const char* const names[] PROGMEM = {st, pe, le, ti};    //массив ссылок на эти строки

void print_names(int names_num);       //функция выводит строки меню

void setup() {

  lcd.init();
  lcd.backlight();

  pinMode(sp7, OUTPUT);
  pinMode(sp5, OUTPUT);
  pinMode(sp3, OUTPUT);
  pinMode(sp1, OUTPUT);
  pinMode(pre_in, OUTPUT);
  pinMode(led, OUTPUT);

}

void loop() {

  enc.tick();   //опрос энкодера
  btn.tick();   //опрос кнопки

  static uint8_t sp_num [] {sp7, sp5, sp3, sp1, pre_in};              //массив номеров точек
  static uint8_t sp_num_size = sizeof(sp_num) / sizeof(sp_num[0]);    //его размер
  static bool stop_flag = true;   //"стоп" флаг, включает и выключает симуляцию поезда
  static bool start_flag;         //"старт" флаг, устанавливает начальное состояние симуляции
  static uint8_t upd_countr = 0;
  if (btn.isClick()) {            //если кнопка нажата
    stop_flag = !stop_flag;       //изменить состояние "стоп" флага
    if (stop_flag) {              //если он поднят
      ++upd_countr;
      for (uint8_t i = 0; i < sp_num_size; ++i) digitalWrite(sp_num[i], LOW);    //освободить все точки
    } else start_flag = true;     //иначе поднять "старт" флаг
  }
  static uint32_t period = 30;
  if (!stop_flag) {               //если "стоп" флаг опущен, включить симуляцию поезда
    static bool state_flag;       //флаг состояний
    static uint8_t countr;        //счетчик
    static uint32_t period_tmr;   //таймер
    if (start_flag) {             //если "старт" флаг поднят
      digitalWrite(sp_num[0], HIGH);    //первая точка "занята", начальное состояние
      countr = 1;                 //установить счетчик в начальное состояние
      upd_countr = 1;
      state_flag = true;          //установить флаг состояний в начальное состояние
      period_tmr = millis();      //обновить таймер
      start_flag = false;         //"старт" флаг опустить
    }
    if (millis() - period_tmr >= period * 1000) {     //дальше почти без изменений
      period_tmr = millis();
      ++upd_countr;
      switch (state_flag) {
        case (true): {
            digitalWrite(sp_num[countr], HIGH);
            if (countr == 1 && digitalRead(sp_num[sp_num_size - 1])) digitalWrite(sp_num[sp_num_size - 1], LOW);      //если счетчик в начальном состоянии, а последняя точка нет, выключить ее
            state_flag = false;
          }
          break;
        case (false): {
            digitalWrite(sp_num[countr - 1], LOW);
            ++countr;
            if (countr == sp_num_size) start_flag = true;       //если счетчик дошел до конца массива, вернуть начальное состояние
            state_flag = true;
          }
          break;
      }
    }
  }

  static uint32_t upd_tmr;
  static uint8_t column = 1;
  if (millis() - upd_tmr >= 100) {    //вывод информации на дисплей построчно
    upd_tmr = millis();
    static bool print_names_flag = true;
    lcd.setCursor(column, 0);
    if (print_names_flag) print_names(&names[0]);       //"State"
    static uint8_t pre_upd_countr = 1;
    if (pre_upd_countr != upd_countr) {                 //состояние точек обновляется по факту изменения
      pre_upd_countr = upd_countr;
      for (uint8_t i = 0, j = 6; i < sp_num_size; ++i, ++j) {
        bool sp_state = (digitalRead(j));               //считать состояние точки
        lcd.print(sp_state);                            //вывести на дисплей
        lcd.print(" ");
      }
    }
    lcd.setCursor(column, 1);
    if (print_names_flag) print_names(&names[1]);       //"Period"
    lcd.print(period);                                  //значение периода
    if (print_names_flag) lcd.print(F(" sec"));         //"sec"
    lcd.setCursor(column, 2);
    if (print_names_flag) {
      print_names(&names[2]);       //"Uptime"
      lcd.setCursor(13, 2);
      lcd.print(F(" reset"));
    }
    lcd.setCursor(column, 3);
    if (print_names_flag) print_names(&names[3]);       //"Timer"
    if (print_names_flag) {
      print_names_flag = false;
      column = 9;
    }
  }
  static uint32_t time_tmr;
  static uint16_t uptime_sec_count = 0;
  static uint16_t timer_sec_count = 3600;
  static bool timer_start = false;
  if (millis() - time_tmr >= 1000) {
    time_tmr = millis();
    if (!stop_flag) ++uptime_sec_count;
    if (timer_start) {
      --timer_sec_count;
      if (timer_sec_count == 0) {
        stop_flag = true;
        ++upd_countr;
        for (uint8_t i = 0; i < sp_num_size; ++i) digitalWrite(sp_num[i], LOW);
        timer_start = false;
      }
    }
    lcd.setCursor(9, 2);
    uptime(uptime_sec_count);
    lcd.setCursor(9, 3);
    timer(timer_sec_count);
    lcd.print(timer_start ? F("  on") : F(" off"));
  }

  static uint8_t cursor_string = 0;
  static uint8_t cursor_column = 0;
  static bool main_menu = true;
  if (main_menu) {
    if (enc.isLeft()) cursor_string = constrain(cursor_string - 1, 0, 3);
    if (enc.isRight()) cursor_string = constrain(cursor_string + 1, 0, 3);
    lcd.setCursor(cursor_column, cursor_string);
    lcd.write(126);
  }
  static uint8_t pre_cursor_string = 0;
  if (pre_cursor_string != cursor_string) {
    lcd.setCursor (cursor_column, pre_cursor_string);
    lcd.print(" ");
    pre_cursor_string = cursor_string;
  }
  static uint8_t pre_cursor_column = 0;
  if (pre_cursor_column != cursor_column) {
    lcd.setCursor (pre_cursor_column, cursor_string);
    lcd.print(" ");
    pre_cursor_column = cursor_column;
  }
  static bool menu_item_enter = true;
  static bool menu_item_available = false;
  static bool menu_sub_item_enter = false;
  static uint8_t sp_num_count;
  switch (cursor_string) {
    case (0): {
        if (menu_item_enter && enc.isClick()) {
          cursor_column = 8;
          sp_num_count = 0;
          main_menu = false;
          menu_item_enter = false;
          menu_item_available = true;
        }
        if (menu_item_available) {
          lcd.setCursor(cursor_column, cursor_string);
          lcd.write(126);
          if (enc.isLeft()) {
            cursor_column = constrain(cursor_column - 2, 8, 16);
            sp_num_count = constrain(sp_num_count - 1, 0, 4);
          }
          if (enc.isRight()) {
            cursor_column = constrain(cursor_column + 2, 8, 16);
            sp_num_count = constrain(sp_num_count + 1, 0, 4);
          }
          if (enc.isClick()) {
            digitalWrite((sp_num[sp_num_count]), !digitalRead(sp_num[sp_num_count]));
            ++upd_countr;
          }
          if (enc.isHolded()) {
            cursor_column = 0;
            main_menu = true;
            menu_item_enter = true;
            menu_item_available = false;
          }
        }
      }
      break;
    case (1): {
        if (menu_item_enter && enc.isClick()) {
          cursor_column = 8;
          lcd.setCursor(cursor_column, cursor_string);
          lcd.write(126);
          main_menu = false;
          menu_item_enter = false;
          menu_item_available = true;
        }
        if (menu_item_available) {
          if (enc.isLeft()) {
            if (enc.isFast()) period = constrain(period - 5, 15, 60);
            else period = constrain(period - 1, 15, 60);
          }
          if (enc.isRight()) {
            if (enc.isFast()) period = constrain(period + 5, 15, 60);
            else period = constrain(period + 1, 15, 60);
          }
        }
        if (enc.isHolded()) {
          cursor_column = 0;
          main_menu = true;
          menu_item_enter = true;
          menu_item_available = false;
        }
      }
      break;
    case (2): {
        if (menu_item_enter && enc.isClick()) {
          cursor_column = 13;
          lcd.setCursor(cursor_column, cursor_string);
          lcd.write(126);
          main_menu = false;
          menu_item_enter = false;
          menu_item_available = true;
        }
        if (menu_item_available) {
          if (enc.isClick()) uptime_sec_count = 0;
        }
        if (enc.isHolded()) {
          cursor_column = 0;
          main_menu = true;
          menu_item_enter = true;
          menu_item_available = false;
        }
      }
      break;
    case (3): {
        if (menu_item_enter && enc.isClick()) {
          cursor_column = 8;
          main_menu = false;
          menu_item_enter = false;
          menu_item_available = true;
        }
        if (menu_item_available) {
          lcd.setCursor(cursor_column, cursor_string);
          lcd.write(126);
          if (!menu_sub_item_enter) {
            if (enc.isLeft()) cursor_column = 8;
            if (enc.isRight()) cursor_column = 13;
          }
          switch (cursor_column) {
            case (8): {
                if (!menu_sub_item_enter && enc.isClick()) {
                  menu_sub_item_enter = true;
                }
                if (menu_sub_item_enter) {
                  if (enc.isLeft()) {
                    if (enc.isFast()) timer_sec_count = constrain(timer_sec_count - 3600, 1, 35940);
                    else timer_sec_count = constrain(timer_sec_count - 60, 1, 35940);
                  }
                  if (enc.isRight()) {
                    if (enc.isFast()) timer_sec_count = constrain(timer_sec_count + 3600, 1, 35940);
                    else timer_sec_count = constrain(timer_sec_count + 60, 1, 35940);
                  }
                  if (menu_sub_item_enter && enc.isHolded()) menu_sub_item_enter = false;
                }
              }
              break;
            case (13): {
                if (enc.isClick()) timer_start = !timer_start;
              }
              break;
          }
        }
        if (!menu_sub_item_enter && enc.isHolded()) {
          cursor_column = 0;
          main_menu = true;
          menu_item_enter = true;
          menu_item_available = false;
        }
      }
      break;
  }

}

void uptime(uint16_t sec_count) {
  uint8_t min_count = sec_count / 60;
  uint8_t this_hour = sec_count / 3600;
  lcd.print(this_hour);
  lcd.print(":");
  uint8_t this_min = min_count % 60;
  if (this_min < 10) lcd.print(0);
  lcd.print(this_min);
}

void timer(uint16_t sec_count) {
  uint8_t min_count = sec_count / 60;
  uint8_t this_hour = sec_count / 3600;
  lcd.print(this_hour);
  lcd.print(":");
  uint8_t this_min = min_count % 60;
  if (this_min < 10) lcd.print(0);
  lcd.print(this_min);
}

void print_names(int names_num) {
  char buff[20];
  uint16_t ptr = pgm_read_word(names_num);
  uint8_t i = 0;
  do {
    buff[i] = (char)(pgm_read_byte(ptr++));
  } while (buff[i++] != NULL);
  lcd.print(buff);
}
